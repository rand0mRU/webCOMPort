<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<meta name="viewwindow.port" content="width=device-width, initial-scale=1.0">
	<title>webPlotter</title>
	<script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>

<body class="dark:bg-gray-800">
	<div class="p-5 pb-0">
		<div class="shadow-md border-gray-300 p-2 inline-block">
			<label for="baudRate" class="block mb-2 text-lg font-bold text-gray-900 dark:text-white">Подключение</label>
			<select style="display: inline-block;" id="baudRate"
				class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500">
				<option>300</option>
				<option>600</option>
				<option>750</option>
				<option>1200</option>
				<option>2400</option>
				<option>4800</option>
				<option selected>9600</option>
				<option>19200</option>
				<option>31250</option>
				<option>38400</option>
				<option>57600</option>
				<option>57600</option>
				<option>74880</option>
				<option>115200</option>
				<option>230400</option>
				<option>250000</option>
			</select>
			<button type="button" style="display: inline-block;"
				class="focus:outline-none text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 me-2 ms-2 mb-2 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800"
				onclick="connectToSerial()">Подключиться</button>
			<button type="button" style="display: inline-block;"
				class="focus:outline-none text-white focus:ring-4 font-medium rounded-lg text-sm px-5 py-2.5 me-2 mb-2 bg-blue-600 hover:bg-blue-700 focus:ring-blue-800"
				onclick="nowRead = false;disconnectFromSerial()">Отключится</button>
		</div>
	</div>
	<div id="forCanvas" class="p-5 pt-3">
		<div id="plotter">
			<ul class="flex flex-wrap text-sm font-medium text-center text-gray-400 mb-3">
				<li class="me-2">
					<a href="#canvas"
						class="inline-block px-4 py-3 text-white bg-blue-600 rounded-lg active">Плоттер</a>
				</li>
				<li class="me-2">
					<a href="#"
						class="monPortActivate inline-block px-4 py-3 rounded-lg hover:bg-gray-800 hover:text-white">Монитор
						порта</a>
				</li>
			</ul>

			<p class="block mb-2 text-xl font-bold text-gray-900 dark:text-white">Плоттер</p>
			<canvas id="canvas" class="h-[90vh] w-full bg-gray-700 rounded-lg mb-3"></canvas>
			<div class="shadow-md border-gray-300 p-3">
				<p class="text-xl text-gray-900 dark:text-white mb-3 font-bold">Настройки</p>

				<div class="flex items-center mb-4">
					<input id="autosize" type="checkbox" value="" class="w-4 h-4 text-blue-600 rounded-sm focus:ring-blue-500 focus:ring-blue-600 ring-offset-gray-800 focus:ring-2 bg-gray-300 border-gray-600">
					<label for="autosize" class="ms-2 text-sm font-medium text-gray-900 dark:text-gray-300">Автомасштабирование</label>
				</div>

				<div class="mb-5">
					<label for="xmaxtext" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">Ширина
						отрисовки</label>
					<input type="number" id="xmaxtext"
						class="mb-3 bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500" />

					<label for="ymaxtext" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">Высота
						отрисовки</label>
					<input type="number" id="ymaxtext"
						class="mb-3 bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500" />
				</div>
			</div>

		</div>
		<div id="monport">
			<ul class="flex flex-wrap text-sm font-medium text-center text-gray-400 mb-3">
				<li class="me-2">
					<a href="#"
						class="plotterActivate inline-block px-4 py-3 hover:bg-gray-800 hover:text-white rounded-lg">Плоттер</a>
				</li>
				<li class="me-2">
					<a href="#port" class="inline-block px-4 py-3 rounded-lg text-white bg-blue-600 active">Монитор
						порта</a>
				</li>
			</ul>
			<label for="port" class="block mb-2 font-bold text-xl text-gray-900 dark:text-white">Монитор порта</label>
			<textarea id="port" rows="24"
				class="block p-2.5 w-full text-sm text-gray-900 bg-gray-50 rounded-lg border border-gray-300 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 mb-3"
				placeholder="Пока что тут пусто"></textarea>

			<div class="shadow-md border-gray-300 p-3">
				<p class="text-xl text-gray-900 dark:text-white mb-3 font-bold">Настройки</p>

				<div class="flex items-center mb-4">
					<input id="autoscroll" type="checkbox" value="" class="w-4 h-4 text-blue-600 rounded-sm focus:ring-blue-500 focus:ring-blue-600 ring-offset-gray-800 focus:ring-2 bg-gray-300 border-gray-600" checked>
					<label for="autoscroll" class="ms-2 text-sm font-medium text-gray-900 dark:text-gray-300">Автопрокрутка</label>
				</div>
				<div class="mb-5">
					<label for="mxlines" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">Максимальное количество строк</label>
					<input type="number" id="mxlines"
						class="mb-3 bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500" />
				</div>
			</div>
		</div>

	</div>
	<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
	<script>
		function baudRate() {
			return parseInt($("#baudRate").val());
		}

		let isPlotter = true;
		let nowRead = false;
		let autoSize = false;
		let xMax = 100;
		let yMax = 2048;
		// let lastData = [];
		let allData = [];
		let colors = ["green", "red", "blue", "white", "orange"];
		let autoScroll = true;
		let mxLines = 100;

		$("#autosize").change((event) => {
			autoSize = $("#autosize").is(":checked");
			if (!autoSize) {
				xMax = $("#xmaxtext").val();
				yMax = $("#ymaxtext").val();
			}
		});

		$("#autoscroll").change((event) => {
			autoScroll = $("#autoscroll").is(":checked");
		});

		function max(data) {
			let mx = 0;
			data.forEach((element) => {
				if (element > mx)
					mx = element;
			});
			return mx;
		}

		$("#monport").hide();

		$(".plotterActivate").click(() => {
			$("#plotter").show();
			$("#monport").hide();
			isPlotter = true;
		});
		$(".monPortActivate").click(() => {
			$("#plotter").hide();
			$("#monport").show();
			isPlotter = false;
		});

		let canvas = document.getElementById("canvas");
		let forCanvas = document.getElementById("forCanvas");
		canvas.width = forCanvas.offsetWidth;
		canvas.height = forCanvas.offsetHeight;
		console.log(canvas.height);
		let middle = canvas.height / 2;
		// let middle = 0;
		let ctx = canvas.getContext("2d");

		$("#xmaxtext").val(xMax);
		$("#ymaxtext").val(yMax);
		$("#mxlines").val(mxLines);

		$("#xmaxtext").change((event) => {
			xMax = parseInt(event.target.value);
		});
		$("#ymaxtext").change((event) => {
			yMax = parseInt(event.target.value);
		});
		$("#mxlines").change((event) => {
			mxLines = parseInt(event.target.value);
		});

		function abs(x) {
			if (x < 0) return x * -1;
			return x;
		}

		function draw(all) {
			if (isPlotter) {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				all.forEach((data, index) => {
					ctx.beginPath();
					ctx.moveTo(xMax * (canvas.width / xMax), (yMax / canvas.height) * (middle - data[abs(xMax)]));
					ctx.strokeStyle = colors[index];
					for (let i = xMax; i > 0; i--) {
						ctx.lineTo(Math.round(i * (canvas.width / xMax)), Math.round(middle - ((canvas.height / yMax) * (data[abs(xMax - i)]))));
						// console.log(middle - ((canvas.height / (yMax * 2)) * (data[abs(xMax - i)])));
					}
					ctx.stroke();
				});
			}
		}
		function newtext(data) {
			$("#port").append(data + "&NewLine;");

			if ($("#port").text().split('\n').length > mxLines) {
				let content = $("#port").text().split('\n').slice(-mxLines).join('\n');
				$("#port").val(content);
			}
			
			if (autoScroll) document.getElementById("port").scrollTop = document.getElementById("port").scrollHeight;
		}

		async function connectToSerial() {
			try {
				window.port = await navigator.serial.requestPort();
				await window.port.open({ baudRate: baudRate() });
				console.log("Port opened", baudRate());
				await readFromPort();
			} catch (error) {
				alert(error);
			}
		}
		async function disconnectFromSerial() {
			try {
				nowRead = false;
				await window.port.close();
				console.log("Port closed");
			} catch (error) {
				alert(error);
			}
		}
		let buffer = '';

		async function readFromPort() {
			const reader = window.port.readable.getReader();
			nowRead = true;

			try {
				while (true) {
					if (!nowRead) break;

					const { value, done } = await reader.read();
					if (done) {
						nowRead = false;
						break;
					}

					buffer += new TextDecoder().decode(value);

					const lines = buffer.split('\n');

					buffer = lines.pop() || '';

					for (let line of lines) {
						line = line.replace('\r', '').trim();

						if (line) {
							const stringInts = line.match(/-?\d+/g); 

							if (stringInts) {
    							const integers = stringInts.map(numStr => parseInt(numStr));
								
								if (integers.length < allData.length) {
									allData.length = integers.length;
								}
								let maxes = [];
								integers.forEach((number, index) => {
									if (!isNaN(number)) {
										if (allData[index] === undefined)
											allData[index] = [];
										allData[index].unshift(number);
										allData[index].length = xMax;
										maxes.push(max(allData[index]));
									}
								});
								if (autoSize) {
									let ymx = max(maxes);
									yMax = 2 * ymx + (ymx * 0.15);
								}

								draw(allData);
							}

							newtext(line);
						}
					}
				}
			} catch (error) {
				console.log("Error when reading port: ", error);
			} finally {
				reader.releaseLock();
			}
		}
		async function writeToPort(data) {
			const reader = window.port.writable.getWriter();

			try {
				const encoder = new TextEncoder();
				await writer.write(encoder.encode(data));
				console.log("Data sended");
			} catch (error) {
				console.log("Error when read window.port: ", error);
			} finally {
				reader.releaseLock();
			}
		}
	</script>
</body>

</html>